# JavaScript闭包

闭包是JavaScript中的重要内容，官方的定义为：函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

如上所述，闭包是与作用域息息相关的，为了理解闭包的概念，首先我们需要了解JavaScript的作用域概念。

## 作用域

作用域大致可以分为两类，一类是动态作用域，一类是词法作用域，JavaScript所采用的是词法作用域。

与大多数语言相同的是，JavaScript的作用域分为全局作用域和局部作用域，局部作用域分为块级作用域与函数作用域，在ES6之前，实际上块级作用域是不存在的。

所谓全局作用域，一般是定义的最外层函数外的变量和最外层函数，不一般的情况下，包括未声明就直接使用的变量自动提升为全局作用域的变量，以及对象`window`的属性（但实际情况是，最外层函数以及最外层函数外的变量都是该`window`对象的属性）。

函数作用域则顾名思义是函数内部声明的变量和函数内部的定义的方法。

让我们看一组例子：

```javascript
var a=3;
function foo(){
  console.log("a: "+a);
  var b=2;
}
foo();
console.log("b: "+b);
```

以下是它的运行结果：

![运行结果](./img/1.png)

如上所示，运行结果显示了一个`error`，这个错误是典型`ReferenceError`，造成它的原因是因为在`console.log("b: "+b);`时，并没有查找到变量`b`，而`console.log("a: "+a);`却能正常运行。造成上述错误的原因在于在函数`foo()`内部定义的变量`b`的作用域是函数作用域，这意味着这个函数只能在`foo()`被使用。而变量`a`是在函数外部定义的，它的作用域是全局作用域，这意味着虽然在该函数作用域内无法查找到该函数，但可以去函数的作用域外进行查找。

### 作用域遮蔽

现在我们知道了，在函数作用域内声明的变量仅拥有该函数的作用域，在函数外部无法访问该函数，那么如果在函数内部重新声明一个与函数外声明的相同变量，并且同时在函数体内和函数体外打印该变量，这个变量的值会是怎样？

```js
var a=3;
function foo(){
  var a=5;
  console.log(a);
}
foo();
console.log(a);
```

![运行结果](./img/2.png)

答案是，函数体内声明的变量由于处于函数作用域内，它的变量输出就是函数作用域内的值，而函数体外的变量输出则与函数体的新声明的相同名字变量无关，依然是全局作用域下的该变量的值。

现在再看一个例子

```js
var a=2;
function foo(){
  a=5;
}
foo();
console.log(a);
```

以上代码与前一个的区别在于，`a`这个变量在`foo()`内没有声明，因此它的作用域依然全局作用域，那么函数体内对它进行改变是真的修改了全局作用域中该变量的值，那么`console.log(a);`的输出为5。

现在我们再来观察另一种写法：

```js
var a = 5;
function fun1(a){
  a=7;
  console.log(a);
}
fun1(a);
console.log(a);
```

它的运行结果又会与之前的写法不同：

![运行结果](./img/3.png)

原因在于这里全局作用域下的`a`会被作为参数的值传递给函数作用域内的`a`，`fun1(a)`中的`a`是属于函数作用域的，即使把它修改成变的变量名也是可以的，并不会影响全局作用域内的`a`，相同于在函数作用域内重新声明了一个名为`a`的变量。

## 闭包

现在我们已经基本了解了全局作用域，但是所谓的全局作用域也只是比函数作用域大一点的作用域而已，因为全局作用域类内变量和函数依然是在`window`对象的内部。

我们现在来看下面的代码：

```js
function foo(){
  function fun1(){
    console.log("fun1");
  }
}
```

我们能否在`foo()`函数外使用`fun1()`函数？答案是否定的，`fun1()`所在的作用域是`foo()`函数内部，按照作用域的规则我们只能在`foo()`函数内部使用这个函数，函数作用域也可以看成是一个封闭的空间，但并不意味着我们真的无法在函数外部使用内部函数了。

```js
function foo(){
  function fun1(){
    console.log("fun1");
  }
  return fun1;
}
var b=foo();
b();
```

这里实际上就使用了闭包，函数`fun1`作为返回值返回给了变量`b`，那么`b`就成为了函数可以输出`fun1()`作用域内的`console.log("fun1");`。像这样的，在函数外部能访问到函数作用域内定义的变量或者函数，就叫做闭包。

JavaScript具有自动回收机制，由于闭包的存在使得函数的作用域能始终存在，不会被垃圾回收机制回收掉。